# -*- coding: utf-8 -*-
"""SimuladorCache.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RaCzItaZCq2EnRRKZng5CFsbzQNc4sCm
"""

import sys
import numpy as np

#parametros
nsets = 256       #número de conjuntos
bsize = 4         #tamanho do bloco
assoc = 1         #grau de associatividade (1 = mapeamento direto)
subst = "R"       #política de substituição (R = Random, L = LRU, F = FIFO, A = LRU Approximation)
flag_saida = 1    #formato da saída (0 = detalhado, 1 = compacto)
arquivo_entrada = "/content/bin_1000.bin"

#Func para política de substituição de cache
def politica_substituicao(subst, indice_inicial, indice_final, ordem_cache, ordem_acesso, etiqueta_cache, etiqueta, fifo_index, lru_bits):
    if subst == "R":  # Random
        indice_cache = np.random.randint(indice_inicial, indice_final)
    elif subst == "L":  # LRU
        indice_cache = indice_inicial + np.argmin(ordem_cache[indice_inicial:indice_final])
        ordem_cache[indice_cache] = ordem_acesso
    elif subst == "F":  # FIFO
        indice_cache = fifo_index % (indice_final - indice_inicial) + indice_inicial
        fifo_index += 1
        ordem_cache[indice_cache] = ordem_acesso
    elif subst == "A":  # clock replacement (pra menor custo computacional)
        while True:
            if lru_bits[fifo_index] == 0:
                indice_cache = fifo_index
                break
            lru_bits[fifo_index] = 0
            fifo_index = (fifo_index + 1) % (indice_final - indice_inicial) + indice_inicial
        fifo_index += 1
    else:
        print("Política de substituição inválida!")
        return None

    etiqueta_cache[indice_cache] = etiqueta
    return ordem_cache, etiqueta_cache, fifo_index, lru_bits

#func para mapeamento associativo de cache
def map_associativo(indice_inicial, indice_final, valor_cache, etiqueta_cache, etiqueta, ordem_cache, ordem_acesso, subst, fifo_index, lru_bits):
    stats = {'hit': 0, 'miss': 0, 'missCompulsorio': 0, 'missConflito': 0, 'missCapacidade': 0}

    for i in range(indice_inicial, indice_final):
        if valor_cache[i] == 1 and etiqueta_cache[i] == etiqueta:
            stats['hit'] += 1
            ordem_cache[i] = ordem_acesso
            if subst == "A":
                lru_bits[i] = 1  # att o bit para indicar uso recente
            return stats, fifo_index, lru_bits

    stats['miss'] += 1
    if 0 in valor_cache[indice_inicial:indice_final]:
        stats['missCompulsorio'] += 1
        for i in range(indice_inicial, indice_final):
            if valor_cache[i] == 0:
                valor_cache[i] = 1
                etiqueta_cache[i] = etiqueta
                ordem_cache[i] = ordem_acesso
                return stats, fifo_index, lru_bits

    stats['missCapacidade'] += 1
    ordem_cache, etiqueta_cache, fifo_index, lru_bits = politica_substituicao(subst, indice_inicial, indice_final, ordem_cache, ordem_acesso, etiqueta_cache, etiqueta, fifo_index, lru_bits)
    return stats, fifo_index, lru_bits

#Imprimir estatisticas
def imprimir_dados_cache(dados):
    hit, numero_acesso, miss, miss_compulsorio, miss_capacidade, miss_conflito, flag_saida = dados
    taxa_hit = hit / numero_acesso
    taxa_miss = miss / numero_acesso
    taxa_miss_compulsorio = (miss_compulsorio / miss) if miss > 0 else 0
    taxa_miss_capacidade = (miss_capacidade / miss) if miss > 0 else 0
    taxa_miss_conflito = (miss_conflito / miss) if miss > 0 else 0

    if flag_saida == 0:
        print(f"Número de acessos: {numero_acesso}")
        print(f"Taxa de hits: {taxa_hit:.4f}\tNúmero de hits: {hit}")
        print(f"Taxa de misses: {taxa_miss:.4f}\tNúmero de misses: {miss}")
        print(f"Taxa de misses compulsório: {taxa_miss_compulsorio:.4f}\tNúmero de misses compulsório: {miss_compulsorio}")
        print(f"Taxa de misses de capacidade: {taxa_miss_capacidade:.4f}\tNúmero de misses de capacidade: {miss_capacidade}")
        print(f"Taxa de misses de conflito: {taxa_miss_conflito:.4f}\tNúmero de misses de conflito: {miss_conflito}")
    elif flag_saida == 1:
        print(numero_acesso, f"{taxa_hit:.4f}", f"{taxa_miss:.4f}", f"{taxa_miss_compulsorio:.4f}", f"{taxa_miss_capacidade:.4f}", f"{taxa_miss_conflito:.4f}")
    else:
        print("Flag de saída inválida!")

#func mapeamento associativo de cache
def map_associativo(indice_inicial, indice_final, valor_cache, etiqueta_cache, etiqueta, ordem_cache, ordem_acesso, subst, fifo_index, lru_bits):
    stats = {'hit': 0, 'miss': 0, 'missCompulsorio': 0, 'missConflito': 0, 'missCapacidade': 0}

    # Verifica se já está na cache (HIT)
    for i in range(indice_inicial, indice_final):
        if valor_cache[i] == 1 and etiqueta_cache[i] == etiqueta:
            stats['hit'] += 1
            ordem_cache[i] = ordem_acesso  # Atualiza a ordem de acesso para LRU/FIFO
            if subst == "A":
                lru_bits[i] = 1  # Indica uso recente na LRU Approximation
            return stats, fifo_index, lru_bits

    # Se não estiver, é um MISS
    stats['miss'] += 1

    # MISS COMPULSÓRIO - Se houver um espaço vazio no conjunto
    for i in range(indice_inicial, indice_final):
        if valor_cache[i] == 0:
            stats['missCompulsorio'] += 1
            valor_cache[i] = 1
            etiqueta_cache[i] = etiqueta
            ordem_cache[i] = ordem_acesso  # Atualiza ordem de acesso para LRU/FIFO
            return stats, fifo_index, lru_bits

    # Se todos os conjuntos estiverem cheios, pode ser CONFLITO ou CAPACIDADE
    total_blocos = len(valor_cache)  # Total de blocos na cache
    blocos_ocupados = sum(valor_cache)  # Quantos blocos estão ocupados

    if blocos_ocupados < total_blocos:
        stats['missConflito'] += 1  # Se há espaço na cache total, mas não no conjunto, é CONFLITO
    else:
        stats['missCapacidade'] += 1  # Se a cache inteira está cheia, é CAPACIDADE

    # Aplica política de substituição (R, F, L, A)
    ordem_cache, etiqueta_cache, fifo_index, lru_bits = politica_substituicao(
        subst, indice_inicial, indice_final, ordem_cache, ordem_acesso, etiqueta_cache, etiqueta, fifo_index, lru_bits
    )

    return stats, fifo_index, lru_bits

import os
print(os.listdir("/content"))

#main
def main():
    valor_cache = np.zeros(nsets * assoc, dtype=int)
    etiqueta_cache = np.full(nsets * assoc, -1)
    ordem_cache = np.zeros(nsets * assoc, dtype=int)
    lru_bits = np.zeros(nsets * assoc, dtype=int)
    stats = {'numeroAcesso': 0, 'hit': 0, 'miss': 0, 'missCompulsorio': 0, 'missCapacidade': 0, 'missConflito': 0}
    fifo_index = 0

    n_bits_offset = int(np.log2(bsize))
    n_bits_index = int(np.log2(nsets))
    n_bits_tag = 32 - n_bits_offset - n_bits_index

    with open(arquivo_entrada, 'rb') as f:
        while (data := f.read(4)):
            endereco = int.from_bytes(data, byteorder='big')
            stats['numeroAcesso'] += 1
            etiqueta = endereco >> (n_bits_offset + n_bits_index)
            indice = (endereco >> n_bits_offset) & ((1 << n_bits_index) - 1)
            ordem_acesso = stats['numeroAcesso']

            indice_inicio, indice_fim = indice * assoc, (indice + 1) * assoc
            temp_stats, fifo_index, lru_bits = map_associativo(indice_inicio, indice_fim, valor_cache, etiqueta_cache, etiqueta, ordem_cache, ordem_acesso, subst, fifo_index, lru_bits)
            for k in temp_stats:
                stats[k] += temp_stats[k]

    imprimir_dados_cache((stats['hit'], stats['numeroAcesso'], stats['miss'], stats['missCompulsorio'], stats['missCapacidade'], stats['missConflito'], flag_saida))


main()